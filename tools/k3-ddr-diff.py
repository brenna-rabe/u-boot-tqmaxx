#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-or-later

# Copyright (c) 2023 TQ-Systems GmbH <u-boot@ew.tq-group.com>,
# D-82229 Seefeld, Germany.
# Author: Matthias Schiffer

'''
Compares two TI K3 RAM timing DTSIs and generates a patch DTSI fragment.
Currently, only AM64x/AM62x SoCs are supported.
'''

# Missing for support of other K3 SoCs:
# - Dynamic setting of NUM_CTL, NUM_PI and NUM_PHY
# - Support for the optional DDRSS_PLL_FREQUENCY_0 field

import inspect
import logging
import os
import subprocess
import sys

from crccheck.crc import Crc16Xmodem
from struct import pack

NUM_CTL = 423
NUM_PI = 345
NUM_PHY = 1406

class DTSIReader:
	'''
	Handles reading of DDR controller configuration from a DTSI generated by
	TI's tooling.
	'''

	def __init__(self, keys):
		'''
		Creates a new DTSIReader

		keys is a list of all defines expected in the read DTSI files.
		'''
		self._cpp = os.getenv('CPP') or 'cpp'
		logging.info("Using '%s' as preprocessor", self._cpp)

		self._keys = keys
		self._input = '\n'.join(keys)

	def _run_cpp(self, file):
		'''
		Runs the C preprocessor

		Defines are read from the passed DTSI file. A string containing
		all names expected to be defined in the file is passed in as input.
		'''
		return subprocess.run(
			[self._cpp, '-P', '-imacros', file],
			check=True,
			encoding='ascii',
			input=self._input,
			stdout=subprocess.PIPE,
		).stdout

	def parse_dtsi(self, file):
		'''
		Reads a DTSI file (in the well-known format generated by TI's tooling)
		and returns a dictionary with all defines in the file.
		'''
		logging.info("Reading DTSI '%s'", file)

		output = self._run_cpp(file)
		values = output.split()

		# _run_cpp() inputs the newline-separated list of keys to cpp's
		# stdin. cpp should replace each key with the value defined in
		# the DTSI, so if everything worked correctly, output should
		# be a newline-separated list of the values in the order of
		# the keys in the input.

		if len(values) != len(self._keys):
			raise RuntimeError('Invalid output from preprocessor')

		ret = {}

		for index, key in enumerate(self._keys):
			try:
				val = int(values[index], 0)
			except ValueError as exc:
				raise Exception(f"DTSI did not define '{key}' to a valid number") from exc

			ret[key] = val

		return ret

def key_name(name, index):
	return f'DDRSS_{name}_{index}_DATA'

def gen_keys(name, num):
	return [key_name(name, index) for index in range(num)]

def diff_dtsi(dtsi1, dtsi2, name, num):
	'''
	Returns a list of values that differ between two DTSI files and the
	CRC16-CCITT of the second DTSI's data

	The returned list contains tuples of the full key name, the index for
	the current kind of key, and the second value.

	The data is encoded in little-endian for the purpose of CRC calculation.
	'''
	diff = []
	crc = Crc16Xmodem()

	for index in range(num):
		key = key_name(name, index)
		val1 = dtsi1[key]
		val2 = dtsi2[key]

		if val1 != val2:
			diff.append((key, index, val2))

		crc.process(pack('<I', val2))

	return diff, crc.final()

def print_patch_diff(name, diff):
	print(f'{name} = <')

	for key, index, val in diff:
		print(f'\t{index} 0x{val:08x} /* {key} */')

	print('>;')

def print_patch(dtsi1, dtsi2):
	logging.info('Generating patch DTSI')

	ddr_freq1 = dtsi2['DDRSS_PLL_FREQUENCY_1']
	ddr_freq2 = dtsi2['DDRSS_PLL_FREQUENCY_2']
	ddr_fhs_cnt = dtsi2['DDRSS_PLL_FHS_CNT']

	ctl_diff, ctl_crc = diff_dtsi(dtsi1, dtsi2, 'CTL', NUM_CTL)
	pi_diff, pi_crc = diff_dtsi(dtsi1, dtsi2, 'PI', NUM_PI)
	phy_diff, phy_crc = diff_dtsi(dtsi1, dtsi2, 'PHY', NUM_PHY)

	print(f'ti,ddr-freq1 = <{ddr_freq1}>;')
	print(f'ti,ddr-freq2 = <{ddr_freq2}>;')
	print(f'ti,ddr-fhs-cnt = <{ddr_fhs_cnt}>;')
	print()

	print_patch_diff('ti,ctl-data-patch', ctl_diff)
	print(f'ti,ctl-data-crc16 = <0x{ctl_crc:04x}>;')

	print_patch_diff('ti,pi-data-patch', pi_diff)
	print(f'ti,pi-data-crc16 = <0x{pi_crc:04x}>;')

	print_patch_diff('ti,phy-data-patch', phy_diff)
	print(f'ti,phy-data-crc16 = <0x{phy_crc:04x}>;')

	print()
	print('bootph-pre-ram;')

def usage():
	'''
	Prints usage information
	'''

	print((
		'Usage: k3-ddr-diff.py <base DTSI> <variant DTSI>\n'
		'\n'
		f'{inspect.cleandoc(sys.modules[__name__].__doc__)}\n'
		'\n'
		'The generated patch DTSI will be emitted to stdout.\n'
	), end='', file=sys.stderr)

def main():
	'''
	The k3-ddr-diff main function
	'''
	if len(sys.argv) != 3:
		usage()
		sys.exit(1)

	file1 = sys.argv[1]
	file2 = sys.argv[2]

	logging.basicConfig(level=logging.INFO)

	keys = ['DDRSS_PLL_FHS_CNT', 'DDRSS_PLL_FREQUENCY_1', 'DDRSS_PLL_FREQUENCY_2'] \
		+ gen_keys('CTL', NUM_CTL) \
		+ gen_keys('PI', NUM_PI) \
		+ gen_keys('PHY', NUM_PHY)

	reader = DTSIReader(keys)

	dtsi1 = reader.parse_dtsi(file1)
	dtsi2 = reader.parse_dtsi(file2)

	print('/*')
	print(' * Generated by k3-ddr-diff.py')
	print(' *')
	print(f' *   Base DTSI:    {file1}')
	print(f' *   Variant DTSI: {file2}')
	print(' */')
	print()

	print_patch(dtsi1, dtsi2)

if __name__ == '__main__':
	main()
